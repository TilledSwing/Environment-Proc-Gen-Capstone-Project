// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainDensity
#include "/FastNoiseLite.hlsl"

RWStructuredBuffer<float> HeightsBuffer;
StructuredBuffer<float> TerrainNoiseBuffer;
StructuredBuffer<float> CaveNoiseBuffer;
// Terrain Values
int height;
bool terracing;
int terraceHeight;
float isolevel;

uint ChunkSize;
float3 ChunkPos;

int FlattenIndex(float3 id, int size) {
    return id.x * (size + 1) * (size + 1) + id.y * (size + 1) + id.z;
}

[numthreads(4,4,4)]
void TerrainDensity (uint3 id : SV_DispatchThreadID)
{

    if(id.x >= ChunkSize+1 || id.y >= ChunkSize+1 || id.z >= ChunkSize+1) {
        return ;
    }

    float caveNoise = CaveNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)];
    float caveCarve = smoothstep(-0.4, 0.0, caveNoise); // [0,1] â†’ caves near 0.0
    caveCarve = 1.0 - caveCarve; // Invert so center of cave = 1.0, outside = 0.0

    float terrainNoise = TerrainNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)];
    float currentHeight = (height * ((terrainNoise+1)/2) + (terracing ? (id.y%terraceHeight) : 0));

    float terrainDensity = currentHeight - (ChunkPos.y + id.y);
    float surfaceFade = saturate((terrainDensity) / 60.0);
    // float surfaceFade = smoothstep(-1.0, 50.0, terrainDensity);
    float caveFade = saturate((terrainDensity - ChunkSize) / 70.0);
    
    HeightsBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] = terrainDensity + ((ChunkPos.y + id.y) * caveFade) - (caveCarve * height * surfaceFade);
}
