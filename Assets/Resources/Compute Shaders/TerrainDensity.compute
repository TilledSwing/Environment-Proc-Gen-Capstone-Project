// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainDensity
#include "/FastNoiseLite.hlsl"

RWStructuredBuffer<float> HeightsBuffer;
// RWStructuredBuffer<int> WaterCheckBuffer;
// RWStructuredBuffer<int> UndergroundCheckBuffer;
StructuredBuffer<float> BaseNoiseBuffer;
StructuredBuffer<float> LargeCaveNoiseBuffer;
StructuredBuffer<float> CaveDetailNoiseBuffer;
StructuredBuffer<float> ContinentalnessNoiseBuffer;
StructuredBuffer<float> TemperatureNoiseBuffer;
StructuredBuffer<float> HumidityNoiseBuffer;
StructuredBuffer<float> PeaksAndValleysNoiseBuffer;
// Terrain Values
int height;
bool terracing;
int terraceHeight;
float isolevel;

uint ChunkSize;
float3 ChunkPos;
int MaxWorldYChunks;

// Convert a 3D array index into a 1D flat array index
int FlattenIndex(float3 id, int size) {
    return id.x * (size + 1) * (size + 1) + id.y * (size + 1) + id.z;
}
// Compute total density of terrain use provided noise data
[numthreads(4,4,4)]
void TerrainDensity (uint3 id : SV_DispatchThreadID)
{

    if(id.x >= ChunkSize+1 || id.y >= ChunkSize+1 || id.z >= ChunkSize+1) {
        return ;
    }

    float caveNoise = LargeCaveNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)];
    float caveCarve = smoothstep(-0.4, 0.0, caveNoise);
    caveCarve = 1.0 - caveCarve;

    float terrainNoise = BaseNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)];
    float currentHeight = (height * ((terrainNoise+1)/2) + (terracing ? (id.y%terraceHeight) : 0));

    float terrainDensity = currentHeight - (ChunkPos.y + id.y);
    float surfaceFade = saturate((terrainDensity) / 60.0);
    float caveFade = saturate((terrainDensity - ChunkSize) / 70.0);
    float finalDensity = terrainDensity + ((ChunkPos.y + id.y) * caveFade) - (caveCarve * height * surfaceFade);
    if (ChunkPos.y / ChunkSize == -MaxWorldYChunks) {
        float fadeStart = ChunkSize * 0.1;
        float fadeRange = ChunkSize * 0.2;
        float worldDepthFade = saturate((id.y - fadeStart) / fadeRange);

        float caveSuppression = caveCarve * height * surfaceFade * worldDepthFade;
        finalDensity = terrainDensity + ((ChunkPos.y + id.y) * caveFade) - caveSuppression;
    }
    
    HeightsBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] = finalDensity;
}
