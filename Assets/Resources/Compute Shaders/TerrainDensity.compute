// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainDensity
#include "/FastNoiseLite.hlsl"

RWStructuredBuffer<float> HeightsBuffer;
StructuredBuffer<float> BaseNoiseBuffer;
StructuredBuffer<float> LargeCaveNoiseBuffer;
bool LargeCaveNoiseActivated;
StructuredBuffer<float> CaveDetailNoiseBuffer;
bool CaveDetailNoiseActivated = false;
StructuredBuffer<float> ContinentalnessNoiseBuffer;
bool ContinentalnessNoiseActivated = false;
StructuredBuffer<float> TemperatureNoiseBuffer;
bool TemperatureNoiseActivated = false;
StructuredBuffer<float> HumidityNoiseBuffer;
bool HumidityNoiseActivated = false;
StructuredBuffer<float> PeaksAndValleysNoiseBuffer;
bool PeaksAndValleysNoiseActivated = false;
StructuredBuffer<float> ErosionNoiseBuffer;
bool ErosionNoiseActivated = false;
// Terrain Values
int height;
bool terracing;
int terraceHeight;
float isolevel;

uint ChunkSize;
float3 ChunkPos;
int MaxWorldYChunks;

// Convert a 3D array index into a 1D flat array index
int FlattenIndex(float3 id, int size) {
    return id.x * (size + 1) * (size + 1) + id.y * (size + 1) + id.z;
}
// Compute total density of terrain use provided noise data
[numthreads(4,4,4)]
void TerrainDensity (uint3 id : SV_DispatchThreadID)
{

    if(id.x >= ChunkSize+1 || id.y >= ChunkSize+1 || id.z >= ChunkSize+1) {
        return ;
    }

    // Activation checks don't actually work yet cause hlsl is weird
    float terrainNoise = BaseNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)];
    float baseTerrainHeight = (terrainNoise+1)/2;
    float largeCaveNoise = (LargeCaveNoiseActivated ? LargeCaveNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] : 0);
    float continentalnessNoise = (ContinentalnessNoiseActivated ? ContinentalnessNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] : 0);
    // float erosionNoise = (ErosionNoiseActivated ? ErosionNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] : 0);
    // float peaksAndValleysNoise = (PeaksAndValleysNoiseActivated ? PeaksAndValleysNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] : 0);

    // Continentalness
    float adjustedBaseTerrainHeight = (ContinentalnessNoiseActivated ? baseTerrainHeight * ((continentalnessNoise + 1.5) * 0.5) : baseTerrainHeight);
    // Erosion
    // adjustedBaseTerrainHeight *= (ErosionNoiseActivated ? lerp(0.3, 1.0, ((erosionNoise * -1) + 1) / 2) : 1);

    // Cave Carve Calculation
    float caveCarve = smoothstep(-0.4, 0.0, largeCaveNoise);
    caveCarve = 1.0 - caveCarve;
    // Terrain Density Calculation
    float currentHeight = ((height * adjustedBaseTerrainHeight) + (terracing ? (id.y%terraceHeight) : 0));
    float terrainDensity = currentHeight - (ChunkPos.y + id.y);
    // Cave Fade
    float surfaceFade = saturate((terrainDensity) / 60.0);
    float caveFade = saturate((terrainDensity - ChunkSize) / 70.0);
    float finalDensity = LargeCaveNoiseActivated ? terrainDensity + ((ChunkPos.y + id.y) * caveFade) - (caveCarve * height * surfaceFade) : terrainDensity;
    // World Depth Fade
    if (ChunkPos.y / ChunkSize == -MaxWorldYChunks) {
        float fadeStart = ChunkSize * 0.1;
        float fadeRange = ChunkSize * 0.2;
        float worldDepthFade = saturate((id.y - fadeStart) / fadeRange);

        float caveSuppression = caveCarve * height * surfaceFade * worldDepthFade;
        finalDensity = terrainDensity + ((ChunkPos.y + id.y) * caveFade) - caveSuppression;
    }

    HeightsBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] = finalDensity;
}
