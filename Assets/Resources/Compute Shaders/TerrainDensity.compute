// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TerrainDensity
#include "/FastNoiseLite.hlsl"

RWStructuredBuffer<float> HeightsBuffer;
// RWStructuredBuffer<int> WaterCheckBuffer;
// RWStructuredBuffer<int> UndergroundCheckBuffer;
StructuredBuffer<float> TerrainNoiseBuffer;
StructuredBuffer<float> CaveNoiseBuffer;
// Terrain Values
int height;
bool terracing;
int terraceHeight;
float isolevel;

uint ChunkSize;
float3 ChunkPos;
int MaxWorldYChunks;

// Convert a 3D array index into a 1D flat array index
int FlattenIndex(float3 id, int size) {
    return id.x * (size + 1) * (size + 1) + id.y * (size + 1) + id.z;
}
// Compute total density of terrain use provided noise data
[numthreads(4,4,4)]
void TerrainDensity (uint3 id : SV_DispatchThreadID)
{

    if(id.x >= ChunkSize+1 || id.y >= ChunkSize+1 || id.z >= ChunkSize+1) {
        return ;
    }

    float caveNoise = CaveNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)];
    float caveCarve = smoothstep(-0.4, 0.0, caveNoise);
    caveCarve = 1.0 - caveCarve;
    // float caveCarve = smoothstep(-0.2, 0.0, caveNoise);
    // caveCarve = 0.8 - caveCarve;



    float terrainNoise = TerrainNoiseBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)];
    float currentHeight = (height * ((terrainNoise+1)/2) + (terracing ? (id.y%terraceHeight) : 0));

    float terrainDensity = currentHeight - (ChunkPos.y + id.y);
    float surfaceFade = saturate((terrainDensity) / 60.0);
    float caveFade = saturate((terrainDensity - ChunkSize) / 70.0);
    float finalDensity = terrainDensity + ((ChunkPos.y + id.y) * caveFade) - (caveCarve * height * surfaceFade);
    if (ChunkPos.y / ChunkSize == -MaxWorldYChunks) {
        float fadeStart = ChunkSize * 0.1;
        float fadeRange = ChunkSize * 0.2;
        float worldDepthFade = saturate((id.y - fadeStart) / fadeRange);

        float caveSuppression = caveCarve * height * surfaceFade * worldDepthFade;
        finalDensity = terrainDensity + ((ChunkPos.y + id.y) * caveFade) - caveSuppression;
    }
    // if(WaterCheckBuffer[0] != 1) {
    //     WaterCheckBuffer[0] = terrainDensity > isolevel && finalDensity <= isolevel ? 0 : 1;
    // }
    // if(UndergroundCheckBuffer[0] != 0) {
    //     UndergroundCheckBuffer[0] = finalDensity < isolevel ? 0 : 1;
    // }
    HeightsBuffer[FlattenIndex(float3(id.x,id.y,id.z), ChunkSize)] = finalDensity;
}
